% Kira Whitehouse
% kbw2116

function navigate_wall2(port)

%Initialize variables
v= 0.3;                     % Forward velocity (m/s)
w= 0;                       % Angular velocity (rad/s)
totalDistanceTraveled = 0;  % Distance meter
totalAngleTurned = 0;       % Angle meter
goalX = 0;                  % Initial X position
goalY = 0;                  % Initial Y position
timeout = 1200;             % Time until program exits


%Move robot forwards until we hit something
SetFwdVelAngVelCreate(port, v, w);

%Check bump sensors
[BumpRight, BumpLeft, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
bumped= BumpRight || BumpLeft || BumpFront;

while ~bumped
    [BumpRight, BumpLeft, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
    bumped= BumpRight || BumpLeft || BumpFront;
end

v = 0;
w = v2w(v);
if BumpRight
    disp('right');
    rotate(port, -w);
elseif BumpLeft
    disp('left');
    rotate(port, -w);
elseif BumpFront   
    disp('front');
    rotate(port, -w);
end

disp('at starting position');

% Reset angular and linear odometry
AngleSensorRoomba(port);     
DistanceSensorRoomba(port);


while (goalX ~= 0 && goalY ~= 0 && timeout > 0) || (totalDistanceTraveled == 0) 
    SetFwdVelAngVelCreate(port, 0.5, 0);
    pause(0.1);
    
    disp('in main loop');
    Wall = ReadWallSensor(port);
    [BumpRight, BumpLeft, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
    bumped= BumpRight || BumpLeft || BumpFront;
    disp(BumpFront);

    if ~Wall 
        disp('lost wall');
        pause(0.3);
        v = 0.3;
        w = v2w(v);
        SetFwdVelAngVelCreate(port,v, -w);
        while ~Wall && ~bumped
            pause(0.1);
            Wall = ReadWallSensor(port);
            [BumpRight, BumpLeft, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
            bumped= BumpRight || BumpLeft || BumpFront;
        end
        v = 0;
        w = v2w(v);
        rotate(port, -w);
    end
    
    while BumpFront
            disp('bump front');
            v = 0;
            w = v2w(v);
            
            SetFwdVelAngVelCreate(port, v, w);
            while Wall || BumpFront || BumpRight
                disp('we are touching wall');
            	pause(0.1);
                Wall = ReadWallSensor(port);
                [BumpRight, ~, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
            end
            rotate(port, v -w);

            %{
            SetFwdVelAngVelCreate(port, v, w)
            turn= 0;
            angle = pi/3;
            while turn < angle
            	turn= turn + abs(AngleSensorRoomba(port));
            	pause(0.1);
            end
            %}
            
            %{ 
            
            SetFwdVelAngVelCreate(port, v, -w)
            turn= 0;
            angle = pi/4;
            while turn < angle
            	turn= turn + abs(AngleSensorRoomba(port));
            	pause(0.1);
            end
            
            rotate(port, -w);
            %}
            disp('should be at starting position after bump front');
            [~, ~, ~, ~, ~, BumpFront] = BumpsWheelDropsSensorsRoomba(port);
    end
    timeout = timeout - 1;
    
end 
%}

% Stop robot motion
v= 0;
w= 0;
SetFwdVelAngVelCreate(port,v,w);

% If you call RoombaInit inside the control program, this would be a
% good place to clean up the serial port with...
% fclose(port)
% delete(port)
% clear(port)
% Don't use these if you call RoombaInit prior to the control program
end


%rotate clockwise or counterclockwise
%input direction is boolean, velocity is signed angular rotation
function angle = rotate(port, angularVelocity)

%read wall sensor
Wall = ReadWallSensor(port);

%turn until we sense a wall on our right
while ~Wall  
	disp('rotating towards wall');
	SetFwdVelAngVelCreate(port, 0, angularVelocity);
	pause(0.1);
	Wall = ReadWallSensor(port);
end

%how many radians we have turned
angle = AngleSensorRoomba(port);

%zero angular velocity
SetFwdVelAngVelCreate(port, 0, 0);
pause(0.1);

end



function w= v2w(v)
% Calculate the maximum allowable angular velocity from the linear velocity
%
% Input:
% v - Forward velocity of Create (m/s)
%
% Output:
% w - Angular velocity of Create (rad/s)
    
    % Robot constants
    maxWheelVel= 0.5;   % Max linear velocity of each drive wheel (m/s)
    robotRadius= 0.2;   % Radius of the robot (m)
    
    % Max velocity combinations obey rule v+wr <= v_max
    w= (maxWheelVel-v)/robotRadius;
end
